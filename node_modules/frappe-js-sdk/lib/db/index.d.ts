import { AxiosInstance } from 'axios';
import { FieldName, Filter, FrappeDoc, GetDocListArgs, GetLastDocArgs } from './types';
export declare class FrappeDB {
    /** URL of the Frappe App instance */
    private readonly appURL;
    /** Axios instance */
    readonly axios: AxiosInstance;
    /** Whether to use the token based auth */
    readonly useToken: boolean;
    /** Token to be used for authentication */
    readonly token?: () => string;
    /** Type of token to be used for authentication */
    readonly tokenType?: 'Bearer' | 'token';
    constructor(appURL: string, axios: AxiosInstance, useToken?: boolean, token?: () => string, tokenType?: 'Bearer' | 'token');
    /**
     * Get a document from the database
     * @param {string} doctype Name of the doctype
     * @param {string} docname Name of the document
     * @returns Promise which resolves to the document object
     */
    getDoc<T = any>(doctype: string, docname?: string): Promise<FrappeDoc<T>>;
    /**
     * Gets a list of documents from the database for a particular doctype. Add filters, sorting order and pagination to get a filtered and sorted list of documents.
     * @param {string} doctype Name of the doctype
     * @param {@type GetDocListArgs} [args] Arguments for the query
     * @returns Promise which resolves to an array of documents
     */
    getDocList<T = any, K = FrappeDoc<T>>(doctype: string, args?: GetDocListArgs<K>): Promise<T[]>;
    /** Creates a new document in the database
     * @param {string} doctype Name of the doctype
     * @param {Object} value Contents of the document
     * @returns Promise which resolves with the complete document object
     */
    createDoc<T = any>(doctype: string, value: T): Promise<FrappeDoc<T>>;
    /** Updates a document in the database
     * @param {string} doctype Name of the doctype
     * @param {string} docname Name of the document
     * @param {Object} value Contents of the document to update (only the fields that are to be updated)
     * @returns Promise which resolves with the complete document object
     */
    updateDoc<T = any>(doctype: string, docname: string | null, value: Partial<T>): Promise<FrappeDoc<T>>;
    /**
     * Deletes a document in the database
     * @param {string} doctype Name of the doctype
     * @param {string} docname Name of the document
     * @returns Promise which resolves an object with a message "ok"
     */
    deleteDoc(doctype: string, docname?: string | null): Promise<{
        message: string;
    }>;
    /**
     * Gets count of documents from the database for a particular doctype with the given filters
     * @param {string} doctype Name of the doctype
     * @param {@type Filter[]} [filters] Filters to be applied in the count query
     * @param {boolean} [debug] Whether to print debug messages or not
     * @returns Promise which resolves a number
     */
    getCount<T = any>(doctype: string, filters?: Filter<T>[], debug?: boolean): Promise<number>;
    /**
     * Get a document from the database
     * @param {string} doctype Name of the doctype
     * @param {@type GetLastDocArgs} [args] Arguments for the query
     * @returns Promise which resolves to the document object
     */
    getLastDoc<T = any>(doctype: string, args?: GetLastDocArgs<FrappeDoc<T>>): Promise<FrappeDoc<T>>;
    /**
     * Renames a document from the database
     * @param {string} doctype Name of the doctype
     * @param {string} oldname Current name of the document
     * @param {string} newname The new name that will replace the `oldname`
     * @param {boolean} merge  Merges the old document into the new one if a document with `newname` already exists.
     * @returns Promise which resolves with the updated document name
     */
    renameDoc<T = any>(doctype: string, oldname: string | null, newname: string | null, merge?: boolean): Promise<FrappeDoc<T>>;
    /**
     * Retrieves a document's value from the database for a specific doctype using the provided field names and filters.
     * @param {string} doctype Name of the doctype
     * @param {FieldName} [fieldname] - Fields to be returned (default `name`)
     * @param {Filter[]} [filters] Filters to be applied in the get query
     * @param {boolean} asDict Return as dict(object) or list (array)
     * @param {boolean} [debug] Whether to print debug messages or not
     * @param {string} parent Parent doctype name to fetch child table record
     * @returns Promise which resolves an object with specified fieldnames
     */
    getValue<T = any>(doctype: string, fieldname?: FieldName, filters?: Filter<T>[], asDict?: boolean, debug?: boolean, parent?: string | null): Promise<T>;
    /**
     * Sets the field values in the database for the specified doctype.
     * @param {string} doctype Name of the doctype
     * @param {string} name Name of the document
     * @param {string | object} fieldname Fieldname(s) whose value(s) need to be set.
     * @param {any} value Value to be set in fieldname when updating a single field or if `fieldname` is a string.
     * @returns Promise which resolves an updated docoument
     */
    setValue<T = any>(doctype: string, name: string, fieldname: string | object, value?: any): Promise<FrappeDoc<T>>;
    /**
     * Retrieves the field value from the database for a specific single doctype.
     * @param {string} doctype Name of the doctype
     * @param {string} field Name of the field
     * @returns Promise that resolves to the field's value.
     */
    getSingleValue<T = any>(doctype: string, field: string): Promise<T>;
    /**
     * Submit a document.
     * @param {object} doc Document to be submitted
     * @returns Promise that resolves to a submitted document.
     */
    submit<T = any>(doc: object): Promise<T>;
    /**
     * Cancel a document.
     * @param {string} doctype Name of the doctype
     * @param {string} name Name of the document to be cancelled
     * @returns Promise that resolves to a canceled document.
     */
    cancel<T = any>(doctype: string, name: string): Promise<FrappeDoc<T>>;
}
